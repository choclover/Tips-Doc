
趋势科技行动安全防护for Android
http://www.17inda.com/html/2/article-756.html

◎ 应用改进－－快速作出哪怕粗糙的原型试用，小步快跑持续改进，使用中发现问题和体会需求，使用是硬道理
1, 
2, 360更多面向个人市场；PC应该与企业办公软件的安全防护进行结合（如邮件客户端、文档处理软件等），主要面向企业市场。
3, 界面比较清爽但值得改进，字体大小和美观度不足，历史记录有些语焉不详（按需是什么意思？），有些选择框的风格不一致
4, 有些按键可以点击，有些不可以点击，用户体验不一致。
5, 没有退出按钮
6, xxx与云服务结合的不够紧密，如黑白名单数据都在本地存储，没有在云端备份。
7, 阂獬淌呙琛㈦防o、手C追

◎ 生命周期
* Active/Running, Paused, Stopped, Destroyed
* activity从前台到后台，onPause()肯定会被调用，所有保存状态的动作都应该在这个函数中进行。
* APP不可见时就会调用onStop()。
1, 启动APP：onCreate()->onStart()->onResume()
2, BACK键: onPause()->onStop()->onDestory()
3, HOME键: onPause()->onStop()，程序没有被销毁，APP所在栈的上方压入HOME APP  
4, 重启APP: onRestart()->onStart()->onResume()

＝＝＝＝＝＝ 
◎ Android四种启动模式
http://blog.csdn.net/android_tutor/article/details/6310015
http://marshal.easymorse.com/archives/2950
  <activity android:name="ActName" android:launchMode ="singleTask"></activity>

1. standard
* 默认模式，不需要在launchMode中配置。
* 每次startActivity都会创建该Activity的新实例。创建时类似入栈/压栈的操作，按BACK键时会类似出栈/退栈操作。

2. singleTop
* 每次startActivity都会创建该Activity的新实例。但如果有一个该Activity的实例在栈顶，则不再创建，而是使用这个实例。
* singleTop模式，可用来解决栈顶多个重复相同的Activity的问题。

3. singleTask
* 最多只创建该Activity的一个实例。
* 创建该Activity的实例时，会首先检查栈中是否有该Activity的实例，如果有则把该实例上方的activity都pop掉，使得该实例位于栈顶。
* 在一个task中共享一个Activity。

4. singleInstance
* 最多只创建该Activity的一个实例。 
* 在多个task中共享一个Activity，则其状态在各个task中是共享的，而不是每个task中都是初始的状态（要求至少还有一个task未退出正在调用该activity）。
* 从该Activity返回是返回到调用者的activity

◎ TASK
TASK可以认为是一个栈，可放入多个activity。

◎ BroadcastReceiver
Context.registerReceiver(BroadcastReceiver, IntentFilter);

◎ 解析Intent：调用其他Application；使用了设计模式中的中介模式(Mediator Pattern)，即所有的外围组件，都只和系统的核心模块发生联系，通过它进行中转，组件之间不直接联系，松散的耦合。
1, 直接/显示Intent：指定了component属性的Intent(调用setComponent(ComponentName)或者setClass(Context, Class)来指定)
2, 间接/隐式Intent：没有指定comonent属性的Intent。Intent解析机制主要是通过查找已注册在AndroidManifest.xml中的所有IntentFilter及其中定义的Intent，最终找到匹配的Intent。如果一个组件没有IntentFilter, 那么它只能接受显式intent. 如果有, 则能同时接受二者。
  2.1  Action: 如ACTION_VIEW ，ACTION_PICK。目标组件的IntentFilter的action列表中就必须包含有这个action，否则不能匹配；除了系统预定义的Action，大部分都是application内部通用。
  2.2  Data：content://xxxx，或tel://xxxx，http:, mailto:
  2.3  Type：MIME 表示的，比如text/plain
  2.4  Category：主Activity=CATEGORY_LAUNCHER+ACTION_Main；目标组件的IntentFilter的Category列表中就必须包含有这个Category，否则不能匹配；
  2.5  Extras：Bundle 类的对象，由一组可序列化的key/value对组成
  2.6  Flags: FLAG_ACTIVITY_NEW_TASK
    
◎ 设计模式
1, Factory和Abstract Factory：工厂模式是将“具体产品”变成抽象产品进行扩展，抽象工厂模式是对工厂也进行扩展，将具体工厂变成抽象工厂。
2, 优良的继承关系图中，叶子节点是具体类，其他节点应该都是抽象类，也就是说具体类是不被继承的。将尽可能多的共同代码放到抽象类中。
3, Bridge模式：将抽象部分与它的实现部分相分离，使它们都可以独立地变化。两部分之间通常使用聚合（Aggregation）进行连接。
4, Singleton模式
5, Observer: 定义对象间一对多的依赖关系， 当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。 
6, Strategy: 定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户。 
7, Mediator: 所有的外围组件，都只和系统的核心模块发生联系，通过它进行中转；组件之间不直接联系，形成松散的耦合。
8, Facade: 
9, Proxy: 为访问者对象提供一种代理以控制对这个目标对象的访问。
10, Adapter: 将一类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作那些类可以一起工作。 
11, Decrator: 典型如Java IO 系统API。

◎ NDK
1. ndk-bulid
<ndk>/build/host-setup.sh
mkdir jni
javac HelloJni && javah -classpath bin -d jni com.example.hellojni.HelloJni 

2. public native String  stringFromJNI();
static { System.loadLibrary("hello-jni"); }

* hello-jni.c  
jstring
Java_com_example_hellojni_HelloJni_stringFromJNI( JNIEnv* env,
                                                  jobject thiz )
{
    return (*env)->NewStringUTF(env, "Hello from JNI !");
}

* Android.mk:
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE    := hello-jni
LOCAL_SRC_FILES := hello-jni.c

include $(BUILD_SHARED_LIBRARY)
 
3. 把第三方提供的libxxx.so放到<project>/libs/armeabi/下, 代码中写入：
static { System.loadLibray("xxx"); }

◎ class loader
BootstrapLoader <- ExtClassLoader <- AppClassLoader <- CustomClassLoader, 前者是后者的parent。
下层的classloader会委托上层的class loader加载某个类,如果上层找不到才轮到自己。

* 类加载器的顺序是：
先是bootstrap classloader，然后是extension classloader，最后才是system/app classloader。
1, Bootstrap，负责加载Java的核心类。用C++编写，Java中看不到实例，只能返回NULL，是JVM自带的类装载器。
2, ExtClassLoader －－ 扩展类加载器，它负责加载JRE的扩展目录（JAVA_HOME/jre/lib/ext或者由java.ext.dirs系统属性指定的）中JAR的类包。
3, AppClassLoader －－ 系统（也称为应用）类加载器，它负责在JVM被启动时，加载来自在命令java中的-classpath或者java.class.path系统属性或者 CLASSPATH操作系统属性所指定的JAR类包和类路径。总能通过静态方法ClassLoader.getSystemClassLoader()找到该类加载器。

* 每个ClassLoader加载Class的过程是：
1.检测此Class是否载入过（即在cache中是否有此Class），如果有到8,如果没有到2
2.如果parent classloader不存在（没有parent，那parent一定是bootstrap classloader了），到4
3.请求parent classloader载入，如果成功到8，不成功到5
4.请求jvm从bootstrap classloader中载入，如果成功到8
5.寻找Class文件（从与此classloader相关的类路径中寻找）。如果找不到则到7.
6.从文件中载入Class，到8.
7.抛出ClassNotFoundException.
8.返回Class.
其中5.6步我们可以通过覆盖ClassLoader的findClass方法来实现自己的载入策略。甚至覆盖loadClass方法来实现自己的载入过程。

* 双亲代理模型（Parent Delegation）
在此模型下，当一个装载器被请求装载某个类时，它首先委托自己的parent去装载，若parent能装载，则返回这个类所对应的Class对象，若parent不能装载，则由parent的请求者去装载。
在此模型下，用户自定义的class loader不可能装载应该由parent class loader装载的可靠类，从而防止不可靠甚至恶意的代码代替由parent class loader装载的可靠代码。
class loader的编写者可以自由选择不用把请求委托给parent，但正如上所说，会带来安全的问题。
 
* 自定义class loader模型
URL[] us = { new  URL( " file:// "   +  path  +   " /sub/ " )};
ClassLoader loader = new URLClassLoader(us); 

public  Class findClass(String name) {
	byte [] data  =  loadClassData(name);
  return  defineClass(name, data,  0 , data.length);
}

public  byte [] loadClassData(String name) {
	FileInputStream fis  =   null ;
  byte [] data  =   null ;
  try {
  	fis  =   new  FileInputStream( new  File(drive  +  name  +  fileType));
    ByteArrayOutputStream baos  =   new  ByteArrayOutputStream();
    int  ch  =   0 ;
    while  ((ch  =  fis.read())  !=   - 1 ) {
    	baos.write(ch);
    }
    data  =  baos.toByteArray();
    
  } catch  (IOException e) {
		e.printStackTrace();
  }
  return  data;
} 

◎ ◎ ◎ ◎ ◎ 
.

.

.

.

.

.

.

.

.

.

.

.

.

.























